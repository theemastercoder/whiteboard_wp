<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Polo Tactic Board</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f8ff;
        }

        .tactic-board {
            position: relative;
            width: 90%;
            max-width: 730px;
            aspect-ratio: 4 / 3;
            background-color: #add8e6;
            border: 2px solid #000;
            margin-bottom: 20px;
            cursor: crosshair;
        }

        .line {
            position: absolute;
            width: 100%;
            height: 0.5%;
            background-color: #000;
        }

        .two-meter {
            top: 13%;
        }

        .six-meter {
            top: 40%;
        }

        .goal {
            position: absolute;
            width: 20%;
            height: 7%;
            background-color: #ff4500;
            top: -6%;
            left: 40%;
        }

        .player,
        .ball,
        .goalie {
            position: absolute;
            cursor: pointer;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            justify-content: center;
            align-items: center;
            color: black;
            font-weight: bold;
            font-size: 20px;
        }

        .player {
            width: 5%;
            height: 6%;
            border: 2px solid #000;
        }

        .team1 {
            background-color: #ffcc00;
        }

        .team2 {
            background-color: #00bfff;
        }

        .ball {
            width: 3%;
            height: 3.5%;
            background-color: #ff4500;
            border: 2px solid #000;
        }

        .goalie {
            width: 5%;
            height: 6%;
            background-color: #32cd32;
            border: 2px solid #000;
        }

        button {
            padding: 10px 20px;
            font-size: 1rem;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #cccccc;
            /* A light gray color to indicate it's inactive */
            color: #666666;
            /* Muted text color */
            border: 1px solid #aaaaaa;
            /* Muted border color */
            cursor: not-allowed;
            /* Show a "not allowed" cursor on hover */
            opacity: 0.6;
            /* Slight transparency to reinforce it's disabled */
        }

        .posExit {
            bottom: 550px !important;
            position: absolute;
            left: 0px !important;
            padding: 10px 20px;
            font-size: 1rem;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            display: none;

        }

        .posExit:hover {

            background-color: #0056b3;

        }

        #settingsTab {
            position: fixed;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #ffffff;
            border: 1px solid #ddd;
            padding: 20px;
            display: none;
            width: 250px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }



        #buttonContainer {
            display: flex;
            justify-content: center;
            /* Center the buttons horizontally */
            gap: 10px;
            /* Optional: adds space between buttons */
        }

        .setting {
            margin-bottom: 15px;
        }

        .setting label {
            display: block;
            margin-bottom: 5px;
        }

        .setting input[type="range"],
        .setting input[type="color"] {
            width: 100%;
        }

        .setting button {
            width: 100%;
            margin-top: 10px;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #positionDisplay {
            position: fixed;
            bottom: 100px;
            left: 0px;
            background-color: rgba(255, 255, 255, 0.8);
            /* Semi-transparent background */
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-family: Arial, sans-serif;
            font-size: 1rem;
            color: #333;
            max-width: 200px;
            /* To prevent the text from stretching too far */
            /* In case the text is too long */
            z-index: 9999;
            /* Ensure it appears above other content */
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            /* Space between label and slider */
            margin-bottom: 15px;
            font-family: Arial, Helvetica, sans-serif;
        }

        .slider-container label {
            min-width: 100px;
            /* Fixed width for labels */
        }

        @media (max-width: 600px) {
            .player {
                width: 6.5%;
                /* Increase the size of players */
                height: 7.5%;
                border: 1px solid #000;
            }

            .ball {
                width: 4%;
                /* Increase ball size */
                height: 5%;
                border: 1px solid #000;
            }

            .goalie {
                width: 6.5%;
                /* Increase goalie size */
                height: 7.5%;

                border: 1px solid #000;
            }




        }
    </style>
</head>

<body>
    
    <div class="tactic-board" id="tacticBoard">
        <canvas id="recordingArea"></canvas>
        <canvas id="drawingCanvas"></canvas>
        
        <div class="line two-meter"></div>
        <div class="line six-meter"></div>
        <div class="goal"></div>
        <div id="1" class="player team1" data-start-top="13%" data-start-left="12%" data-start-top2="11.77%"
            data-start-left2="15.49%" style="top: 13%; left: 12%;"></div>
        <div id="2" class="player team1" data-start-top="35%" data-start-left="25%" data-start-top2="12.5%"
            data-start-left2="38.14%" style="top: 35%; left: 25%;"></div>
        <div id="3" class="player team1" data-start-top="45%" data-start-left="50%" data-start-top2="11.77%"
            data-start-left2="57.62%" style="top: 45%; left: 50%;"></div>
        <div id="4" class="player team1" data-start-top="35%" data-start-left="75%" data-start-top2="37%"
            data-start-left2="37%" style="top: 35%; left: 75%;"></div>
        <div id="5" class="player team1" data-start-top="13%" data-start-left="88%" data-start-top2="37%"
            data-start-left2="58%" style="top: 13%; left: 88%;"></div>
        <div id="6" class="player team1" data-start-top="20%" data-start-left="50%" data-start-top2="11.77%"
            data-start-left2="79.06%" style="top: 20%; left: 50%;"></div>

        <div id="1" class="player team2" data-start-top="13%" data-start-left="18%" data-start-top2="11.77%"
            data-start-left2="47.27%" style="top: 13%; left: 18%;"></div>
        <div id="2" class="player team2" data-start-top="32%" data-start-left="30%" data-start-top2="12.5%"
            data-start-left2="32.57%" style="top: 32%; left: 30%;"></div>
        <div id="4" class="player team2" data-start-top="32%" data-start-left="70%" data-start-top2="17.31%"
            data-start-left2="57.67%" style="top: 32%; left: 70%;"></div>
        <div id="3" class="player team2" data-start-top="38%" data-start-left="50%" data-start-top2="11.77%"
            data-start-left2="63.61%" style="top: 38%; left: 50%;"></div>
        <div id="5" class="player team2" data-start-top="13%" data-start-left="82%" data-start-top2="11.77%"
            data-start-left2="47.27%" style="top: 13%; left: 82%;"></div>
        <div id="6" class="player team2" data-start-top="12%" data-start-left="50%" data-start-top2="19.68%"
            data-start-left2="37.62%" style="top: 12%; left: 50%;"></div>

        <div class="ball" id="ball" data-start-top="48%" data-start-left="50%" data-start-top2="40%"
            data-start-left2="40%" style="top: 48%; left: 50%;"></div>
        <div class="goalie" id="goalie" data-start-top="0%" data-start-left="50%" data-start-top2="0%"
            data-start-left2="50%" style="top: 0%; left: 50%;"></div>
    </div>
    
    <div id="buttonContainer">
        <button id="settingsButton">Settings</button>
        <button id="sixOnSixButton">6-on-6 Play</button>
        <button id="sixOnFiveButton">6-on-5 Play</button>
        <button id="addstep">Add step</button>
        <button id="positionButton">Player pos</button>
        <button id="recordButton">Start Recording</button>
        
        
    </div>

    <pre id="output" style="white-space: pre-wrap; background: #f4f4f4; padding: 1em;"></pre>
    <div id="settingsTab">
        <div class="setting">
            <label for="colorPicker">Line Color</label>
            <input type="color" id="colorPicker" value="#000000">
        </div>
        <div class="setting">
            <label for="lineThickness">Line Thickness</label>
            <input type="range" id="lineThickness" min="1" max="10" value="2">
        </div>
        <div class="setting">
            <label for="drawingMode">Drawing Mode</label>
            <select id="drawingMode">
                <option value="freehand">Freehand</option>
                <option value="straight">Straight Line</option>
            </select>
        </div>
        <button id="closeSettings">Close Settings</button>
    </div>
    <div id="positionDisplay">

    </div>
  

    
    <button id="positionExit" class="posExit">Exit</button>
    <script>

        const addstep = document.getElementById('addstep');
        const posExit = document.getElementById('positionExit');
        const posOpen = document.getElementById('positionButton')
        const posTab = document.getElementById('positionDisplay')


        const recordExit = document.getElementById('recordExit')
        const team2Players = document.querySelectorAll('.player.team2');
        const elements = document.querySelectorAll('.player, .ball, .goalie');

        const settingsButton = document.getElementById('settingsButton');
        const settingsTab = document.getElementById('settingsTab');
        const closeSettingsButton = document.getElementById('closeSettings');
        const colorPicker = document.getElementById('colorPicker');
        const lineThicknessSlider = document.getElementById('lineThickness');
        const drawingModeSelector = document.getElementById('drawingMode');
        const tacticBoard = document.getElementById('tacticBoard');
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');

        let isDraggingElement = false;
        let drawingMode = 'freehand';
        let lineColor = '#000000';
        let lineThickness = 2;
        let isDrawing = false;
        let lastX = null, lastY = null;
        let lines = [];


        posTab.style.display = 'none';
        posExit.style.display = 'none';
        const recordButton = document.getElementById('recordButton');

      const recordCanvas = document.getElementById('recordingArea');
const ctx2 = recordCanvas.getContext('2d');


// Set canvas size to match tactic board size
recordCanvas.width = tacticBoard.offsetWidth;
recordCanvas.height = tacticBoard.offsetHeight;

let recordedChunks = [];
let mediaRecorder;

function drawTacticBoardOnCanvas() {
    ctx2.clearRect(0, 0, recordCanvas.width, recordCanvas.height);
    
    // Draw the pool
    ctx2.fillStyle = '#add8e6';
    ctx2.fillRect(0, 0, recordCanvas.width, recordCanvas.height);
    
    // Draw the 2m line
    ctx2.beginPath();
    ctx2.moveTo(0, recordCanvas.height * 0.13);
    ctx2.lineTo(recordCanvas.width, recordCanvas.height * 0.13);
    ctx2.strokeStyle = '#000';
    ctx2.stroke();
    
    // Draw the 6m line
    ctx2.beginPath();
    ctx2.moveTo(0, recordCanvas.height * 0.40);
    ctx2.lineTo(recordCanvas.width, recordCanvas.height * 0.40);
    ctx2.stroke();
    
    // Draw the goal
    ctx2.fillStyle = '#ff4500';
    ctx2.fillRect(recordCanvas.width * 0.4, -recordCanvas.height * 0.06, recordCanvas.width * 0.2, recordCanvas.height * 0.07);
    
    // Draw players
    players.forEach((player, index,ball) => {
        const position = getCurrentPosition(player);
        ctx2.beginPath();
        ctx2.arc((position.left * recordCanvas.width / 100)+17, (position.top * recordCanvas.height / 100)+17, recordCanvas.width * 0.025, 0, 2 * Math.PI);
        ctx2.fillStyle = player.classList.contains('team1') ? '#ffcc00' : '#00bfff';
        ctx2.fill();
        ctx2.stroke();
        const ballId = ball.id; // Get the ID of the ball
            // Extract the number after 'ball-'

            // Set the text of the ball to its number
            
        // Draw player number
        ctx2.fillStyle = '#000';
        ctx2.fillStyle = '#000';
        ctx2.font = '20px Arial';
        ctx2.textAlign = 'center';
        ctx2.textBaseline = 'middle';
        ctx2.fillText(player.id, (position.left * recordCanvas.width / 100)+17, (position.top * recordCanvas.height / 100)+17);
    });
    
    // Draw ball
    const ballPosition = getCurrentPosition(document.getElementById('ball'));
    ctx2.beginPath();
    ctx2.arc((ballPosition.left * recordCanvas.width / 100)+17, (ballPosition.top * recordCanvas.height / 100)-17, recordCanvas.width * 0.015, 0, 2 * Math.PI);
    ctx2.fillStyle = '#ff4500';
    ctx2.fill();
    ctx2.stroke();
    
    // Draw goalie
    const goaliePosition = getCurrentPosition(document.getElementById('goalie'));
    ctx2.beginPath();
    ctx2.arc(goaliePosition.left * recordCanvas.width / 100, goaliePosition.top * recordCanvas.height / 100, recordCanvas.width * 0.025, 0, 2 * Math.PI);
    ctx2.fillStyle = '#32cd32';
    ctx2.fill();
    ctx2.stroke();
}

recordButton.addEventListener('click', () => {
    if (!mediaRecorder || mediaRecorder.state === 'inactive') {
        drawTacticBoardOnCanvas(); // Draw initial state
        const stream = recordCanvas.captureStream(15);
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });

        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstart = () => {
            
            captureFrame();
        };

        function captureFrame(timestamp) {
    if (mediaRecorder && mediaRecorder.state === 'recording') {
        drawTacticBoardOnCanvas();
        animationFrameId = requestAnimationFrame(captureFrame);
    }
}

        mediaRecorder.onstop = () => {
            cancelAnimationFrame(animationFrameId);
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = 'tactic_board_recording.webm';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
            }, 100);
            recordedChunks = [];

        };
        mediaRecorder.start(1000);
        
        recordButton.textContent = 'Stop Recording';
    } else {
        mediaRecorder.stop();
        recordButton.textContent = 'Start Recording';
    }
});








/*
recordButton.addEventListener('click', () => {
    if (!mediaRecorder || mediaRecorder.state === 'inactive') {
        recordedChunks = [];
        const stream = tacticBoard.captureStream(30); // Capture at 30 FPS
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });

        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };

        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = 'tactic_board_recording.webm';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        };

        mediaRecorder.start();
        recordButton.textContent = 'Stop Recording';
    } else {
        mediaRecorder.stop();
        recordButton.textContent = 'Start Recording';
    }
});
*/
        // Add the event listener once
        posExit.addEventListener('click', () => {
            posTab.style.display = 'none';
            posExit.style.display = 'none';
        });


     







        // Handle dragging (for both mouse and touch events)
        elements.forEach(element => {
            element.addEventListener('mousedown', dragStart);
            element.addEventListener('touchstart', dragStartTouch);
        });

        function dragStart(e) {
            e.preventDefault();
            const target = e.target;
            const startX = e.clientX - target.offsetLeft;
            const startY = e.clientY - target.offsetTop;

            function dragMove(e) {
                const newX = e.clientX - startX;
                const newY = e.clientY - startY;
                target.style.left = `${newX / tacticBoard.clientWidth * 100}%`;
                target.style.top = `${newY / tacticBoard.clientHeight * 100}%`;

                // Record positions for all elements if recording is active

            }

            function dragEnd() {
                document.removeEventListener('mousemove', dragMove);
                document.removeEventListener('mouseup', dragEnd);
            }

            document.addEventListener('mousemove', dragMove);
            document.addEventListener('mouseup', dragEnd);
        }

        function dragStartTouch(e) {
            e.preventDefault();
            const target = e.target;
            const touch = e.touches[0];
            const startX = touch.clientX - target.offsetLeft;
            const startY = touch.clientY - target.offsetTop;

            function dragMoveTouch(e) {
                const touch = e.touches[0];
                const newX = touch.clientX - startX;
                const newY = touch.clientY - startY;
                target.style.left = `${newX / tacticBoard.clientWidth * 100}%`;
                target.style.top = `${newY / tacticBoard.clientHeight * 100}%`;

                // Record positions for all elements if recording is active

            }

            function dragEndTouch() {
                document.removeEventListener('touchmove', dragMoveTouch);
                document.removeEventListener('touchend', dragEndTouch);
            }

            document.addEventListener('touchmove', dragMoveTouch);
            document.addEventListener('touchend', dragEndTouch);
        }

        // Playback the recorded movements


        // Playback function for multiple objects


        // Pause/Resume playback

        // Restart playback


        const players = document.querySelectorAll('.player');
        players.forEach((ball) => {
            const ballId = ball.id; // Get the ID of the ball
            // Extract the number after 'ball-'

            // Set the text of the ball to its number
            ball.textContent = ballId;

        });

 


        // Function to get the current position of a player
        function getCurrentPosition(player) {
            const rect = player.getBoundingClientRect();

            // Normalize the positions to percentages based on the tacticBoard container
            const containerRect = tacticBoard.getBoundingClientRect();

            return {
                top: (rect.top - containerRect.top) / containerRect.height * 100,  // Percentage of the height
                left: (rect.left - containerRect.left) / containerRect.width * 100  // Percentage of the width
            };
        }

        function updatePlayerPositions() {
            const playerPositions = []; // Initialize an empty array

            players.forEach((player, index) => {
                const currentPosition = getCurrentPosition(player);
                playerPositions.push({
                    player: `player${index}`,
                    top: currentPosition.top.toFixed(2),
                    left: currentPosition.left.toFixed(2)
                });
            });





            posTab.textContent = JSON.stringify(playerPositions, null, 2);
            requestAnimationFrame(updatePlayerPositions);
          
        }

        // Request the next frame to continuously update positions
    

updatePlayerPositions();



        /// Reference the "6-on-5 Play" button
        const sixOnFiveButton = document.getElementById('sixOnFiveButton');

        sixOnFiveButton.addEventListener('click', () => {
            // Eject one player from team2 (example: first player of team2)
            if (team2Players.length > 0) {
                const firstPlayer = team2Players[0];
                firstPlayer.style.opacity = 0; // Hide the player
            }

            // Restore the positions of all players (including team1 and team2)
            elements.forEach(element => {
                // Fetch the new starting positions from the data attributes for the '6-on-5' play
                const startTop2 = element.getAttribute('data-start-top2');
                const startLeft2 = element.getAttribute('data-start-left2');

                if (startTop2 && startLeft2) {
                    // Set the positions based on the new data attributes
                    element.style.top = startTop2;
                    element.style.left = startLeft2;
                    element.style.display = ''; // Ensure element is visible if hidden
                }
            });

            // Clear the canvas for new tactical drawing
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            lines = []; // Reset the lines array
        });








        function resizeCanvas() {
            canvas.width = tacticBoard.clientWidth;
            canvas.height = tacticBoard.clientHeight;
            redrawLines();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        posOpen.addEventListener('click', () => {
            posTab.style.display = 'block';
            posExit.style.display = 'block';
        });







        settingsButton.addEventListener('click', () => {
            settingsTab.style.display = 'block';
        });

        closeSettingsButton.addEventListener('click', () => {
            settingsTab.style.display = 'none';
        });

        colorPicker.addEventListener('input', (event) => {
            lineColor = event.target.value;
        });

        lineThicknessSlider.addEventListener('input', (event) => {
            lineThickness = event.target.value;
        });

        drawingModeSelector.addEventListener('change', (event) => {
            drawingMode = event.target.value;
        });

        // Mouse drawing functionality
        tacticBoard.addEventListener('mousedown', (event) => {
            if (event.target.classList.contains('player') || event.target.classList.contains('ball') || event.target.classList.contains('goalie')) {
                return;
            }
            isDrawing = true;
            [lastX, lastY] = [event.offsetX, event.offsetY];
        });

        tacticBoard.addEventListener('mousemove', (event) => {
            if (!isDrawing) return;

            ctx.strokeStyle = lineColor;
            ctx.lineWidth = lineThickness;
            ctx.lineCap = 'round';

            if (drawingMode === 'freehand') {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(event.offsetX, event.offsetY);
                ctx.stroke();
                [lastX, lastY] = [event.offsetX, event.offsetY];
            } else if (drawingMode === 'straight') {
                redrawLines();
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(event.offsetX, event.offsetY);
                ctx.stroke();
            }
        });

        tacticBoard.addEventListener('mouseup', (event) => {
            if (!isDrawing) return;
            isDrawing = false;
            if (drawingMode === 'straight') {
                lines.push({
                    startX: lastX,
                    startY: lastY,
                    endX: event.offsetX,
                    endY: event.offsetY,
                    color: lineColor,
                    thickness: lineThickness
                });
                redrawLines();
            }
        });

        tacticBoard.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Touch drawing functionality
        tacticBoard.addEventListener('touchstart', (event) => {
            if (event.target.classList.contains('player') || event.target.classList.contains('ball') || event.target.classList.contains('goalie')) {
                return;
            }
            isDrawing = true;
            const touch = event.touches[0];
            [lastX, lastY] = [touch.clientX - tacticBoard.offsetLeft, touch.clientY - tacticBoard.offsetTop];
            event.preventDefault();  // Prevent default behavior like scrolling
        });

        tacticBoard.addEventListener('touchmove', (event) => {
            if (!isDrawing) return;

            const touch = event.touches[0];
            const offsetX = touch.clientX - tacticBoard.offsetLeft;
            const offsetY = touch.clientY - tacticBoard.offsetTop;

            ctx.strokeStyle = lineColor;
            ctx.lineWidth = lineThickness;
            ctx.lineCap = 'round';

            if (drawingMode === 'freehand') {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(offsetX, offsetY);
                ctx.stroke();
                [lastX, lastY] = [offsetX, offsetY];
            } else if (drawingMode === 'straight') {
                redrawLines();
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(offsetX, offsetY);
                ctx.stroke();
            }

            event.preventDefault();  // Prevent default behavior like scrolling
        });

        tacticBoard.addEventListener('touchend', (event) => {
            if (!isDrawing) return;
            isDrawing = false;
            if (drawingMode === 'straight') {
                lines.push({
                    startX: lastX,
                    startY: lastY,
                    endX: event.changedTouches[0].clientX - tacticBoard.offsetLeft,
                    endY: event.changedTouches[0].clientY - tacticBoard.offsetTop,
                    color: lineColor,
                    thickness: lineThickness
                });
                redrawLines();
            }
        });

        tacticBoard.addEventListener('touchcancel', () => {
            isDrawing = false;
        });

        // Function to redraw previously drawn lines
        function redrawLines() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            lines.forEach(line => {
                ctx.strokeStyle = line.color;
                ctx.lineWidth = line.thickness;
                ctx.beginPath();
                ctx.moveTo(line.startX, line.startY);
                ctx.lineTo(line.endX, line.endY);
                ctx.stroke();
            });
        }

        /* // Handle player drag (for both mouse and touch events)
         elements.forEach(element => {
             // Mouse event listeners
             element.addEventListener('mousedown', dragStart);
 
             // Touch event listeners
             element.addEventListener('touchstart', dragStartTouch);
         });
 
         function dragStart(e) {
             e.preventDefault();  // Prevent default behavior (e.g., text selection)
             const target = e.target;
             const startX = e.clientX - target.offsetLeft;
             const startY = e.clientY - target.offsetTop;
 
             function dragMove(e) {
                 const newX = e.clientX - startX;
                 const newY = e.clientY - startY;
                 target.style.left = `${newX / tacticBoard.clientWidth * 100}%`;
                 target.style.top = `${newY / tacticBoard.clientHeight * 100}%`;
             }
 
             function dragEnd() {
                 document.removeEventListener('mousemove', dragMove);
                 document.removeEventListener('mouseup', dragEnd);
             }
 
             document.addEventListener('mousemove', dragMove);
             document.addEventListener('mouseup', dragEnd);
         }
 
         function dragStartTouch(e) {
             e.preventDefault();  // Prevent default behavior (e.g., scrolling)
             const target = e.target;
             const touch = e.touches[0];  // Get the first touch point
             const startX = touch.clientX - target.offsetLeft;
             const startY = touch.clientY - target.offsetTop;
 
             function dragMoveTouch(e) {
                 const touch = e.touches[0];  // Get updated touch point
                 const newX = touch.clientX - startX;
                 const newY = touch.clientY - startY;
                 target.style.left = `${newX / tacticBoard.clientWidth * 100}%`;
                 target.style.top = `${newY / tacticBoard.clientHeight * 100}%`;
             }
 
             function dragEndTouch() {
                 document.removeEventListener('touchmove', dragMoveTouch);
                 document.removeEventListener('touchend', dragEndTouch);
             }
 
             document.addEventListener('touchmove', dragMoveTouch);
             document.addEventListener('touchend', dragEndTouch);
         }
 */

        // Rename and reference the button
        const sixOnSixButton = document.getElementById('sixOnSixButton'); // Use the existing button

        // Modify the "6-on-6" button functionality
        sixOnSixButton.addEventListener('click', () => {
            elements.forEach(element => {
                // Restore the positions from the data attributes
                const startTop = element.getAttribute('data-start-top');
                const startLeft = element.getAttribute('data-start-left');

                if (startTop && startLeft) {
                    element.style.top = startTop;
                    element.style.left = startLeft;
                }

                // Ensure all players (even the previously hidden ones) are visible
                element.style.opacity = 1;
            });

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            lines = [];
        });

    </script>
</body>

</html>
